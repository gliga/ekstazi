/*
 * Copyright 2014-present Milos Gligoric
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.ekstazi.instrument;

import java.util.concurrent.atomic.AtomicInteger;

import org.ekstazi.agent.Instr;
import org.ekstazi.asm.ClassVisitor;
import org.ekstazi.asm.MethodVisitor;
import org.ekstazi.asm.Opcodes;

/**
 * {@link ClassVisitor} that instruments methods for collecting class
 * coverage.  In addition this class instruments loadClass methods (to
 * avoid loading Ekstazi classes from multiple class loaders).
 */
public class CoverageClassVisitor extends ClassVisitor {

    // Java 1.0	45.0
    // Java 1.1	45.3
    // Java 1.2	46.0
    // Java 1.3	47.0
    // Java 1.4	48.0
    // Java 5 49.0
    // Java 6 50.0
    // Java 7 51.0
    // Java 8 52.0
    // Java 9 53.0
    // Java 10 54.0
    // Java 11 55.0
    // Java 12 56.0
    // Java 13 57.0
    // Java 14 58.0
    // Java 15 59.0
    // Java 16 60.0
    // Java 17 61.0
    // Java 18 62.0
    // Java 19 63.0
    // Java 20 64.0
    // Java 21 65.0
    // Java 22 66.0
    // Java 23 67.0

    /** Max supported Java class file version */
    protected final int MAX_SUPPORTED_JAVA_VERSION = 65;

    // TODO: Revisit the need for this var.
    /** Support for old Java version */
    protected final int MIN_OLD_JAVA_VERSION = 100;
    
    /** Name of the class being visited */
    protected final String mClassName;

    /** Class major version */
    private int mVersion;

    /** Access modifier for class being visited */
    protected int mAccess;

    /** Indicates if class being visited should be modified */
    private boolean isModifiable = true;

    /** Indicates if interface is being visited */
    protected boolean mIsInterface;

    /** Probe id for class being visited */
    private final int mProbeId;
    
    /** Count unique probes */
    private static final AtomicInteger sProbeCounter = new AtomicInteger();

    /**
     * Constructor.
     * 
     * @param className
     *            The name of the class in the internal form.
     * @param cv
     *            Nested class visitor.
     */
    public CoverageClassVisitor(String className, ClassVisitor cv) {
        super(Instr.ASM_API_VERSION, cv);
        this.mClassName = className;
        this.mProbeId = sProbeCounter.incrementAndGet();
    }

    @Override
    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
        // If major version is below 49 make it 49 to be able to use .class.
        // We ignore some classes from xpath, as we get
        // "java.lang.ClassFormatError: Illegal UTF8 string in constant pool in class file".
        if (version == 196653
                || mClassName.equals("org/apache/xerces/impl/xpath/regex/ParserForXMLSchema")
                || mClassName.equals("org/apache/xerces/impl/xpath/regex/Token")) {
            isModifiable = false;
        } else if (version < 49 || version > MIN_OLD_JAVA_VERSION) {
            version = 49;
        }
        // Remember version, as we may use it to perform different
        // instrumentation.
        mVersion = version;
        mAccess = access;
        mIsInterface = (mAccess & Opcodes.ACC_INTERFACE) != 0;
        super.visit(version, access, name, signature, superName, interfaces);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
        // 0. Ignore Java 1.1. There are some (ASM) problems with UTF Strings.
        // 1. Ignore versions newer than Java MAX_SUPPORTED_JAVA_VERSION.
        // 2. Ignore methods generated by a compiler (SYNTHETIC and BRIDGE).
        // 3. Ignore native and abstract methods.
        if (isModifiable &&
            (mVersion <= MAX_SUPPORTED_JAVA_VERSION || mVersion >= MIN_OLD_JAVA_VERSION) &&
            (access & Opcodes.ACC_SYNTHETIC) == 0 &&
            (access & Opcodes.ACC_BRIDGE) == 0 &&
            (access & Opcodes.ACC_NATIVE) == 0 &&
            (access & Opcodes.ACC_ABSTRACT) == 0) {
            // Note that we do not ignore classes that are older than 49 (when
            // ldc could not load .class, but we treat them specially; see the
            // visitor).
            boolean isNewerThanJava4 = mVersion >= 49 && mVersion <= MAX_SUPPORTED_JAVA_VERSION;
            mv = createMethodVisitor(mv, mClassName, access, name, isNewerThanJava4);
            // Special treatment for custom ClassLoaders (see the visitor).
            // TODO: Need to ensure that this is subclass of ClassLoader.
            if ((access & Opcodes.ACC_STATIC) == 0 &&
                name.equals("loadClass") &&
                (desc.equals(Instr.STRING_Z_CLASS_DESC) || desc.equals(Instr.STRING_CLASS_DESC))) {
                mv = new LoaderMethodVisitor(mv);
            }
            mv = new SystemMethodVisitor(mv);
        }
        return mv;
    }

    /**
     * This method is used to optimize instrumentation. If this flag returns
     * false, there is no reason to replace bytecode for this class.
     */
    public boolean isModifiable() {
        return isModifiable;
    }

    /**
     * Factory method.
     */
    protected MethodVisitor createMethodVisitor(MethodVisitor mv, String className, int access, String name, boolean isNewerThanJava4) {
        return new CoverageMethodVisitor(mClassName, mProbeId, sProbeCounter, access, name, mv, isNewerThanJava4);
    }
}
